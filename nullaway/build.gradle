/*
 * Copyright (C) 2017. Uber Technologies
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import net.ltgt.gradle.errorprone.CheckSeverity

plugins {
    id 'java-library'
    id 'nullaway.java-test-conventions'
}

configurations {
    // A configuration holding the jars for the oldest supported version of Error Prone, to use with tests
    errorProneOldest

    // To resolve the errorprone dependencies for the buildWithNullAway task
    errorproneExtended {
        extendsFrom errorprone
        canBeResolved = true
    }
}

dependencies {
    compileOnly project(":annotations")
    compileOnly libs.auto.service.annotations
    annotationProcessor libs.auto.service
    // Using api following the guidance at https://jspecify.dev/docs/using#gradle
    api libs.jspecify
    compileOnly libs.jetbrains.annotations
    compileOnly libs.javax.inject


    compileOnly libs.error.prone.check.api
    implementation libs.checker.dataflow
    implementation libs.guava

    testImplementation project(":annotations")
    testImplementation libs.junit4
    testImplementation(libs.error.prone.test.helpers) {
        exclude group: "junit", module: "junit"
    }
    testImplementation libs.jetbrains.annotations
    testImplementation libs.bundles.junit.jupiter
    testImplementation libs.checker.qual
    testImplementation libs.checker.compat.qual
    testImplementation libs.jspecify
    testImplementation project(":test-java-lib")
    testImplementation libs.jakarta.inject
    testImplementation libs.javax.inject
    testImplementation libs.rxjava2
    testImplementation libs.commons.lang
    testImplementation libs.commons.lang3
    testImplementation project(":test-library-models")
    testImplementation libs.lombok
    testImplementation libs.spring.beans
    testImplementation libs.spring.context
    testImplementation libs.grpc.core
    testImplementation project(":test-java-lib-lombok")
    testImplementation libs.mockito
    testImplementation libs.javax.annotation
    testImplementation libs.assertj
    testImplementation libs.amazon.utils
    testImplementation libs.jakarta.annotations
    // This is for a test exposing a CFG construction failure in the Checker Framework.  We can probably remove it once
    // the issue is fixed upstream and we update. See https://github.com/typetools/checker-framework/issues/6396.
    testImplementation 'org.apache.spark:spark-sql_2.12:3.3.2'

    errorProneOldest "com.google.errorprone:error_prone_check_api:${oldestErrorProneVersion}"
    errorProneOldest("com.google.errorprone:error_prone_test_helpers:${oldestErrorProneVersion}") {
        exclude group: "junit", module: "junit"
    }
    errorProneOldest libs.guava

    // without this, some other version of the JetBrains annotations gets pulled in via transitive dependencies
    errorProneJdk17 libs.jetbrains.annotations
    errorProneOldest libs.jetbrains.annotations
}

javadoc {
    failOnError = false
}

apply plugin: 'com.vanniktech.maven.publish'

// These --add-exports arguments are required when targeting JDK 11+ since Error Prone and NullAway access a bunch of
// JDK-internal APIs that are not exposed otherwise.
tasks.withType(JavaCompile).configureEach {
    options.compilerArgs += [
        "--add-exports=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED",
        "--add-exports=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED",
        "--add-exports=jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED",
        "--add-exports=jdk.compiler/com.sun.tools.javac.comp=ALL-UNNAMED",
        "--add-exports=jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED",
        "--add-exports=jdk.compiler/com.sun.tools.javac.model=ALL-UNNAMED",
        "--add-exports=jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED",
        "--add-exports=jdk.compiler/com.sun.tools.javac.processing=ALL-UNNAMED",
        "--add-exports=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED",
        "--add-exports=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED",
        "--add-exports=jdk.compiler/com.sun.source.tree=ALL-UNNAMED",
    ]
}

// Create a task to test with the oldest supported version of Error Prone
// (while still building against the latest supported version)
def epOldestTest = tasks.register("testErrorProneOldest", Test) {
    javaLauncher = javaToolchains.launcherFor {
        languageVersion = JavaLanguageVersion.of(17)
    }

    description = "Runs the test suite using the oldest supported version of Error Prone"
    group = LifecycleBasePlugin.VERIFICATION_GROUP

    // Copy inputs from normal Test task.
    def testTask = tasks.getByName("test")
    // A bit of a hack: we add the dependencies of the oldest supported Error Prone version to the _beginning_ of the
    // classpath, so that they are used instead of the latest version.  This exercises the scenario of building
    // NullAway against the latest supported Error Prone version but then running on the oldest supported version.
    classpath = configurations.errorProneOldest + testTask.classpath

    testClassesDirs = testTask.testClassesDirs

    jvmArgs += [
        "--add-exports=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED",
        "--add-exports=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED",
        "--add-exports=jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED",
        "--add-exports=jdk.compiler/com.sun.tools.javac.model=ALL-UNNAMED",
        "--add-exports=jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED",
        "--add-exports=jdk.compiler/com.sun.tools.javac.processing=ALL-UNNAMED",
        "--add-exports=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED",
        "--add-exports=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED",
        "--add-opens=jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED",
        "--add-opens=jdk.compiler/com.sun.tools.javac.comp=ALL-UNNAMED",
        // Accessed by Lombok tests
        "--add-opens=jdk.compiler/com.sun.tools.javac.jvm=ALL-UNNAMED",
    ]
}

tasks.named('check').configure {
    dependsOn(epOldestTest)
}

['test', 'testJdk21'].each { taskName ->
    tasks.named(taskName).configure {
        filter {
            // On Error Prone 2.46.0 and above, this test will not pass, since CompilationTestHelper passes the
            // -XDaddTypeAnnotationsToSymbol flag by default.  The test is still run on JDK 17.
            excludeTestsMatching "com.uber.nullaway.ErrorProneCLIFlagsConfigTest.missingTypeAnnotationSymbolFlagForJSpecifyModeOnOlderJDK"
        }
    }
}

// Create a task to build NullAway with NullAway checking enabled
tasks.register('buildWithNullAway', JavaCompile) {
    // Configure compilation to run with Error Prone and NullAway
    source = sourceSets.main.java
    classpath = sourceSets.main.compileClasspath
    destinationDirectory.set(layout.buildDirectory.dir('ignoredClasses'))
    options.annotationProcessorPath = files(
            configurations.errorproneExtended.asCollection(),
            sourceSets.main.annotationProcessorPath,
            // This refers to the NullAway jar built from the current source
            jar.archiveFile.get(),
            sourceSets.main.compileClasspath)
    options.errorprone.enabled = true
    options.errorprone {
        disableAllChecks = true
        error("NullAway")
        option("NullAway:AnnotatedPackages", "com.uber,org.checkerframework.nullaway,com.google.common")
        option("NullAway:CastToNonNullMethod", "com.uber.nullaway.NullabilityUtil.castToNonNull")
        option("NullAway:CheckOptionalEmptiness")
        option("NullAway:AcknowledgeRestrictiveAnnotations")
        option("NullAway:CheckContracts")
        option("NullAway:JSpecifyMode")
    }
    // Make sure the jar has already been built
    dependsOn 'jar'
    // Check that the NullAway jar actually exists (without this,
    // Gradle will run the compilation even if the jar doesn't exist)
    doFirst {
        assert jar.archiveFile.get().getAsFile().exists()
    }
}

project.tasks.named('check').configure {
    dependsOn 'buildWithNullAway'
}
