package com.uber.nullaway.handlers;

import com.google.errorprone.VisitorState;
import com.google.errorprone.util.ASTHelpers;
import com.sun.source.tree.ClassTree;
import com.sun.source.tree.Tree;
import com.sun.source.util.TreePath;
import com.sun.tools.javac.code.Symbol;
import com.uber.nullaway.ErrorMessage;

public class LombokHandler extends BaseNoOpHandler {

  /**
   * Find out if we are inside the FooBuilder generated by lombok as an inner class for `@Builder
   * Foo`.
   *
   * @param state the Visitor State
   * @return if we are inside FooBuilder for some `@Builder Foo`.
   */
  private static boolean isInsideLombokBuilder(VisitorState state) {
    // First, get the immediate containing class (candidate FooBuilder)
    TreePath path = state.getPath();
    while (!path.getLeaf().getKind().equals(Tree.Kind.CLASS)) {
      path = path.getParentPath();
    }
    ClassTree classTree = (ClassTree) path.getLeaf();
    // Check the name first since that is fast
    if (!classTree.getSimpleName().toString().endsWith("Builder")) {
      return false;
    }
    // Now check that it's a nested class
    Symbol.ClassSymbol classSymbol = ASTHelpers.getSymbol(classTree);
    if (!classSymbol.getNestingKind().isNested()) {
      return false;
    }
    // Traverse to finding the containing class (candidate `@Builder Foo`)
    path = path.getParentPath();
    while (!path.getLeaf().getKind().equals(Tree.Kind.CLASS)) {
      path = path.getParentPath();
    }
    ClassTree containingClass = (ClassTree) path.getLeaf();
    // Check for the @Builder annotation
    return ASTHelpers.getSymbol(containingClass)
        .getAnnotationMirrors()
        .stream()
        .anyMatch(a -> a.getAnnotationType().toString().equals("lombok.Builder"));
  }

  @Override
  public boolean onPreErrorReporting(ErrorMessage errorMessage, VisitorState state) {
    return !isInsideLombokBuilder(state);
  }
}
